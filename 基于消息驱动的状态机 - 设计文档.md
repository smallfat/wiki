---
title: 基于消息驱动的状态机 - 设计文档
tags: 
grammar_cjkRuby: true
---
# 目的
- 设计一个状态机
- 由消息进行状态驱动
- 包含状态注册、自动状态迁移、强制状态迁移、事件触发、定时器注册、定时器触发(协程内)等功能
# 设计
### 原理示意图

![绘图](./attachments/1643273500405.drawio.svg)
### 功能模块
###### 状态注册
- 状态注册包含两个方面
	- 状态迁移的注册 - 建立某状态与下一个状态的映射关系，即：某状态 + 消息 =》下一个状态。上述关系会保存在状态迁移repository内
	- 状态对应action的注册 - 建立某状态与其action的映射关系，即：状态 =》 action。此关系保存在状态action repository内。
	- 每个状态包含三个阶段的action:
		- PHASE_PRE - 进入此状态后，首次执行的action。只执行一次。
		- PHASE_MAIN - 此状态的常规执行action。可执行多次。
		- PHASE_POST - 离开此状态之前，最后执行的action。只执行一次。

###### 状态迁移
- 系统提供了两种状态迁移方法：自动状态迁移与强制状态迁移
	- 若当前状态与消息，满足状态注册映射关系，当前状态会切换到下一个状态。即自动状态迁移。
	- 用户还可以强制系统迁移到指定状态，即强制状态迁移。

###### 事件触发
- 进入每个状态，首次执行PHASE_PRE action
- 之后重复执行PHASE_MAIN action，一直到准备迁移到下一个状态。
- 状态的PHASE_POST action在正式迁移到下一个状态之前自动执行。

###### 定时器
- 定时器的注册和触发，利用了coroutine的timer机制
- 当coroutine timer事件触发后，将相关事件信息push进channel，这样就形成了当前协程内的timer触发
# 使用限制考虑
- channel这种容器更适合发射后不管这种设计方式，因此，push入channel的message，由状态机负责进行内存释放
- eventloop是一种简单的单循环结构，无需引入复杂的内存管理机制，因此，要求压入channel的message，其内存生命周期由状态机控管理，该内存最好单独由状态机使用